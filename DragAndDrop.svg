<?xml version='1.0' standalone='no'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 20001102//EN'
  'http://www.w3.org/TR/2000/CR-SVG-20001102/DTD/svg-20001102.dtd'>
<svg width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'
   onload='Init(evt)'
   onmousedown='Grab(evt)'
   onmousemove='Drag(evt)'
   onmouseup='Drop(evt)'>

   <title>Drag And Drop</title>

   <desc>
      A nice little demo of drag-and-drop functionality in SVG,
      written by Doug Schepers on February 16, 2004.
      Use or misuse this code however you wish.
   </desc>

   <script><![CDATA[
      var SVGDocument = null;
      var SVGRoot = null;

      var TrueCoords = null;
      var GrabPoint = null;
      var BackDrop = null;
      var DragTarget = null;

	  var c1 = null;
	   var c2 = null;
	   var gc1=null;
	   var gc2=null;
	   var r=document.getElementById("rc1c2");
	   var rect=null;
	   var sxa = null;
	   var sya = null;
	   var txa = null;
	   var tya = null;
	   var lastsx=null;
	   var lastsy=null;
	   var lasttx=null;
	   var lastty=null;
      function Init(evt)
      {
         SVGDocument = evt.target.ownerDocument;
         SVGRoot = SVGDocument.documentElement;

         // these svg points hold x and y values...
         //    very handy, but they do not display on the screen (just so you know)
         TrueCoords = SVGRoot.createSVGPoint();
         GrabPoint = SVGRoot.createSVGPoint();

         // this will serve as the canvas over which items are dragged.
         //    having the drag events occur on the mousemove over a backdrop
         //    (instead of the dragged element) prevents the dragged element
         //    from being inadvertantly dropped when the mouse is moved rapidly
         BackDrop = SVGDocument.getElementById('BackDrop');
		 gc1 = document.getElementById("gc1");
		 gc2 = document.getElementById("gc2");
      }

      function Grab(evt)
      {
			rect=null;
         // find out which element we moused down on
		 sxa=null;
		 sya=null;
		 txa=null;
		 tya=null;
		 if(evt.target.parentNode == gc1)
		 {
		  sxa = -1;
		  sya = -1;
		  //alert("a");
		  }
		 else if(evt.target.parentNode == gc2)
		 {
		  txa = -1;
		  tya =-1;
		  //alert("b");
		  }
		  else return;
		 
         var targetElement = evt.target.parentNode;

         // you cannot drag the background itself, so ignore any attempts to mouse down on it
         if ( BackDrop != targetElement )
         {
            //set the item moused down on as the element to be dragged
            DragTarget = targetElement;

            // move this element to the "top" of the display, so it is (almost)
            //    always over other elements (exception: in this case, elements that are
            //    "in the folder" (children of the folder group) with only maintain
            //    hierarchy within that group
            DragTarget.parentNode.appendChild( DragTarget );

            // turn off all pointer events to the dragged element, this does 2 things:
            //    1) allows us to drag text elements without selecting the text
            //    2) allows us to find out where the dragged element is dropped (see Drop)
            DragTarget.setAttributeNS(null, 'pointer-events', 'none');

            // we need to find the current position and translation of the grabbed element,
            //    so that we only apply the differential between the current location
            //    and the new location
            var transMatrix = DragTarget.getCTM();
			//alert(Number(transMatrix.e));
			
            GrabPoint.x = TrueCoords.x - Number(transMatrix.e);
            GrabPoint.y = TrueCoords.y - Number(transMatrix.f);
			

         }
      };


      function Drag(evt)
      {
	     //alert(rect);
         // account for zooming and panning
		 if(sxa==null && txa==null)
			return;
         GetTrueCoords(evt);
         // if we don't currently have an element in tow, don't do anything
         if (DragTarget)
         {
            // account for the offset between the element's origin and the
            //    exact place we grabbed it... this way, the drag will look more natural
            var newX = TrueCoords.x - GrabPoint.x;
            var newY = TrueCoords.y - GrabPoint.y;

            // apply a new tranform translation to the dragged element, to display
            //    it in its new location
            DragTarget.setAttributeNS(null, 'transform', 'translate(' + newX + ',' + newY + ')');
			if(sxa!=null)
				sxa=newX;
			if(sya!=null)
				sya=newY;
			if(txa!=null)
				txa=newX;
			if(tya!=null)
				tya=newY;
			SetRelation();
			//var rectx = parseInt(parseInt(rect.getAttribute('x'))+parseInt(newX));
			//var recty = parseInt(parseInt(rect.getAttribute('y'))+parseInt(newY));
			//rect.setAttribute('x',rectx);
			//rect.setAttribute('y',recty);
			//alert("parse");
			
			
			
			
			//rect.setAttribute('x',rectx);
			//rect.setAttribute('y',recty);
         }
      };

      function Drop(evt)
      {
         // if we aren't currently dragging an element, don't do anything
		 if(sxa==null && txa==null)
			return;
         if ( DragTarget )
         {
            // since the element currently being dragged has its pointer-events turned off,
            //    we are afforded the opportunity to find out the element it's being dropped on
            var targetElement = evt.target;

            // turn the pointer-events back on, so we can grab this item later
            DragTarget.setAttributeNS(null, 'pointer-events', 'all');
            if ( 'Folder' == targetElement.parentNode.id )
            {
               // if the dragged element is dropped on an element that is a child
               //    of the folder group, it is inserted as a child of that group
               targetElement.parentNode.appendChild( DragTarget );
               //alert(DragTarget.id + ' has been dropped into a folder, and has been inserted as a child of the containing group.');
            }
            else
            {
               // for this example, you cannot drag an item out of the folder once it's in there;
               //    however, you could just as easily do so here
               //alert(DragTarget.id + ' has been dropped on top of ' + targetElement.id);
            }

            // set the global variable to null, so nothing will be dragged until we
            //    grab the next element
            DragTarget = null;
         }
	//SetRelation(evt);
      };


      function GetTrueCoords(evt)
      {
         // find the current zoom level and pan setting, and adjust the reported
         //    mouse position accordingly
         var newScale = SVGRoot.currentScale;
         var translation = SVGRoot.currentTranslate;
         TrueCoords.x = (evt.clientX - translation.x)/newScale;
         TrueCoords.y = (evt.clientY - translation.y)/newScale;
      };
	function SetRelation()
	{
		var r = document.getElementById("rc1c2");
		var s = document.getElementById("c1");
		var t = document.getElementById("c2");
		var sx = s.getAttribute('x');
		var sy = s.getAttribute('y');
		var tx = t.getAttribute('x');
		var ty = t.getAttribute('y');
		var sw = s.getAttribute('width');
		var sh = s.getAttribute('height');
		var tw = t.getAttribute('width');
		var th = t.getAttribute('height');
		sx = parseInt(sx)+(parseInt(sw)/2);
		sy = parseInt(sy)+(parseInt(sh)/2);
		tx = parseInt(tx)+(parseInt(tw)/2);
		ty = parseInt(ty)+(parseInt(th)/2);
		if(sxa!=null)
		{
		
			sx = parseInt(sx)+parseInt(sxa);
			sy = parseInt(sy)+parseInt(sya);
			if(lasttx!=null)
			{
				tx=parseInt(lasttx);
			}
			if(lastty!=null)
			{
				ty=parseInt(lastty);
			}
		}
		if(txa!=null)
		{
			tx = parseInt(tx)+parseInt(txa);
			ty = parseInt(ty)+parseInt(tya);
			if(lastsx!=null)
			{
				sx=parseInt(lastsx);
			}
			if(lastsy!=null)
			{
				sy=parseInt(lastsy);
			}
		}
		lastsx=sx;
		lastsy=sy;
		lasttx=tx;
		lastty=ty;
		r.setAttribute('x1',sx);
		r.setAttribute('y1',sy);
		r.setAttribute('x2',tx);
		r.setAttribute('y2',ty);
		
	}


   ]]></script>

   <rect id='BackDrop' x='-10%' y='-10%' width='110%' height='110%' fill='none' pointer-events='all' />

   <line id="rc1c2" x1="135" y1="110" x2="500" y2="110" stroke="black" stroke-width="2" />
<g id="gc1">
	<rect id="c1"  class="rect" x="50" y="50" width="200" height="120"
stroke="black" stroke-width="2"
fill="yellow" fill-opacity="1" />
	<text x="60" y="75" font-family="Verdana" font-size="20">Class A</text>
	<line x1="50" y1="87" x2="250" y2="87" stroke="black" stroke-width="2" />
	<text x="60" y="105" font-family="Verdana" font-size="15">-private attribute</text>
	<text x="60" y="120" font-family="Verdana" font-size="15">-public attribute</text>
	<line x1="50" y1="135" x2="250" y2="135" stroke="black" stroke-width="2" />
	<text x="60" y="150" font-family="Verdana" font-size="15">+interface(param:string)</text>
</g>
<g id="gc2">
	<rect id="c2" class="rect" x="400" y="50" width="200" height="120"
stroke="black" stroke-width="2"
fill="lightgreen" fill-opacity="1" />
	<text x="410" y="75" font-family="Verdana" font-size="20">Class B</text>
	<line x1="400" y1="87" x2="600" y2="87" stroke="black" stroke-width="2" />
	<text x="410" y="105" font-family="Verdana" font-size="15">-private attribute</text>
	<text x="410" y="120" font-family="Verdana" font-size="15">-public attribute</text>
	<line x1="400" y1="135" x2="600" y2="135" stroke="black" stroke-width="2" />
	<text x="410" y="150" font-family="Verdana" font-size="15">+interface(param:string)</text>
</g>

</svg>
